ステップ1-1: プロジェクト構成の整備とライブラリ設定
作業内容:
推奨されるディレクトリ構成（server/, client/gui/, share/, lib/）を作成（または既存のものを整理）。
shareパッケージに、サーバー・クライアント共通のデータモデルクラス（User.java, Group.java, Schedule.javaなど、今回決定した仕様で）と、通信プロトコルクラス（ClientMessage.java, ServerMessage.javaなど）を配置します。
Gsonライブラリ (gson-2.10.1.jar) をlib/フォルダに配置し、IDEのプロジェクト設定でクラスパスを通します。
コンパイルスクリプト (compile_and_run.sh) を、新しいプロジェクト構成に合わせて修正します（GUI関連のソースファイルもコンパイル対象に含めるなど）。
確認ポイント: サーバーとGUIクライアントが、それぞれエラーなくコンパイル・起動できること。
ステップ1-2: GUIクライアントの通信クラス作成 (Connector.java)
作業内容:
client/パッケージ（またはclient/gui/直下でも可）に、サーバーとの通信を担当するConnector.javaクラスを新規作成します。
このクラスは、CUIのClient.javaの通信部分を参考に、ソケット接続、メッセージの送受信（JSONとGsonを利用）、接続切断などの基本的な機能を持つようにします。
まずは、サーバーに接続し、簡単なリクエスト（例：pingのような疎通確認コマンドをサーバー側に追加しても良い）を送り、レスポンスを受け取れることを確認します。
確認ポイント: Connectorクラスを使ってサーバーに接続し、簡単なメッセージのやり取りができること。
ステップ1-3: ログイン画面のサーバー認証への移行
作業内容:
GUI.LoginScreenから、Connectorを使ってサーバーにLOGINリクエスト (ServerMessageタイプ"LOGIN", データはLoginRequestオブジェクト) を送信するように変更します。
サーバーからのレスポンス (ClientMessageタイプ"LOGIN_SUCCESS"または"LOGIN_FAILED") を受け取り、その結果に応じて画面遷移またはエラーメッセージ表示を行うようにします。
ログイン成功時には、サーバーから返されるshare.Userオブジェクト（と、UserData全体も）を保持し、Calender画面に渡せるようにします。
確認ポイント: GUIのログイン画面から、サーバーに登録されているユーザーで正しくログインでき、Calender画面に遷移できること。不正なID/パスワードではエラーが表示されること。
ステップ1-4: Calender画面の初期データ表示 (グループとカレンダー)
作業内容:
GUI.Calenderのコンストラクタで、ログインしたshare.UserオブジェクトとConnectorインスタンスを受け取るように変更します。
Calender.initializeData()メソッドを、サーバーから初期データを取得するloadInitialServerData()のようなメソッドに置き換えます。
loadInitialServerData()内で、サーバーにGET_USER_DATAリクエストを送信し、返ってきたUserDataオブジェクトを取得します。
取得したUserDataから、所属グループリスト (List<share.Group>) とスケジュールリスト (List<share.Schedule>) を取り出し、これらを元にサイドバーのグループアイコンとカレンダー上の予定（タイトルのみ）を表示するように、createSidebarPanelやupdateCalendar/updateDateCellViewを改修します。
この時点では、GUI側のCalender.GroupやCalender.Appointmentといった内部クラスは、share.Groupとshare.Scheduleに置き換えるか、これらから必要な情報を抽出して表示する形になります。
確認ポイント: ログイン後、Calender画面に、サーバーに保存されている自分の所属グループと関連スケジュールが正しく表示されること。
フェーズ2：主要機能のサーバー連携（参照系から更新系へ）
フェーズ1でデータの表示ができるようになったら、次はいよいよデータの操作（追加・編集・削除）をサーバー経由で行うようにします。
ステップ2-1: 予定の詳細表示・作成・編集・削除機能のサーバー連携
作業内容:
GUI.Calender.AppointmentDialogを、share.Scheduleオブジェクトを扱えるように改修します（isAllDayフラグ、時間指定UIの追加など、決定した仕様に合わせて）。
カレンダー上の予定ボタンクリック時や「+」ボタンクリック時に開くAppointmentDialogの処理を以下のように変更します。
新規作成時: ダイアログで入力された情報を元にshare.Scheduleオブジェクトを作成し、ADD_SCHEDULEリクエストでサーバーに送信。
編集時: 既存のshare.Schedule情報をダイアログに表示。保存時にUPDATE_SCHEDULEリクエスト（または削除＆追加）でサーバーに送信。
削除時: DELETE_SCHEDULEリクエストでサーバーに送信。
各操作の成功後、サーバーから最新のUserDataを再取得し、カレンダー表示を更新します。
他人の予定の閲覧専用表示や、プライバシー設定のロジックもここで実装します。
確認ポイント: GUIから予定のCRUD（作成・読み取り・更新・削除）操作ができ、その結果がサーバーに保存され、他のクライアント（もしあれば、または再ログイン時）にも反映されること。
ステップ2-2: グループ作成・メンバー管理機能のサーバー連携
作業内容:
showCreateGroupDialog: グループ名と初期メンバーをサーバーにCREATE_GROUP_WITH_MEMBERSリクエストで送信。
showGroupMembersDialog: 表示時にGET_GROUP_MEMBERSリクエストでメンバーリストを取得。
showInviteDialog（メンバー追加時）: 選択されたユーザーをADD_GROUP_MEMBERリクエストでサーバーに追加。
マイページからのグループ脱退機能: LEAVE_GROUPリクエストをサーバーに送信。
各操作の成功後、関連するUI（サイドバー、メンバーリストなど）を更新するために、必要に応じてUserDataを再取得。
確認ポイント: GUIからグループの作成、メンバー招待、脱退ができ、その結果がサーバーに保存され、関係するユーザーに反映されること。
フェーズ3：チャット機能の統合
ステップ3-1: チャット送受信と履歴表示のサーバー連携
作業内容:
グループのチャットパネル表示時: GET_CHAT_HISTORYリクエストでサーバーから過去ログを取得し表示。
メッセージ送信時: SEND_CHATリクエストをサーバーに送信。
新着メッセージのリアルタイム表示: Connectorクラスにサーバーからのプッシュメッセージ（CHAT_MESSAGEタイプ）を受信し、GUIのチャットエリアに非同期で追加するロジックを実装（案A）。
確認ポイント: グループ内でチャットメッセージを送受信でき、履歴が正しく表示され、他のメンバーにもリアルタイム（またはそれに近い形）でメッセージが届くこと。
フェーズ4：仕上げとテスト
ステップ4-1: UI/UXの調整とエラーハンドリングの強化
作業内容:
「処理中...」表示の適切な挿入。
サーバーからのエラーレスポンスや通信エラーをユーザーに分かりやすく表示する処理の網羅。
全体の操作感や見た目の最終調整。
確認ポイント: アプリケーション全体がスムーズに動作し、予期せぬエラーにも適切に対応できること。
ステップ4-2: 総合テスト
作業内容: 複数のクライアント（GUIインスタンスを複数起動）を使って、複数ユーザーでの同時操作やデータ共有が正しく行われるか、徹底的にテストします。
確認ポイント: データの一貫性が保たれ、各ユーザーの画面が適切に同期されること。

現在　1-1 完了